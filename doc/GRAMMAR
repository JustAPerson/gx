A recursive descent grammar for the gx language. Because I am insane,
I am writing a recursive descent parser by hand for this.

If a rule uses '<<=' instead of '::=', it means that recursion is
actually left-associative, even though the parse tree produced means
right-associative. This file is a mess, I don't know what I was
thinking...


              <id> ::= (identifier token)
          <number> ::= (any constant integer)
        <constant> ::= (any constant expression)

         <id-list> ::= <id> , <id-list>
                     | <id>
   <constant-list> ::= <constant> , <constant-list>
                     | <constant>


            <file> ::= <unit> <file>
                     | \e
            <unit> ::= unit <id> { <decl-list> }


       <decl-list> ::= <decl> <decl-list>
                     | \e
            <decl> ::= <decl-scope> <decl-body>
      <decl-scope> ::= pub
                     | \e
       <decl-body> ::= <type-decl>
                     | <func-decl>
                     | <global-var-decl>
                     | <const-decl>
                     | <region-decl>


       <type-decl> ::= type <id> : <type-spec> ;
       <type-spec> ::= <id>
                     | <id> < <constant-list> >
                     | * <type-spec>
                     | [ <number> ] <type-spec>
                     | <struct-spec>
                     | <bitvec-spec>

     <struct-spec> ::= struct { <struct-body> }
     <struct-body> ::= <var-decl> <struct-body>
                     | \e

     <bitvec-spec> ::= bitvec <bitvec-size> ( <bitvec-body> )
     <bitvec-size> ::= < <number> >
                     | \e
     <bitvec-body> ::= <bitvec-member> , <bitvec-body>
                     | <bitvec-member>
   <bitvec-member> ::= <number> : <number>
                     | <id> : <number>


 <global-var-decl> ::= var <storage> <var-decl>
         <storage> ::= <storage-loc> <storage-params>
     <storage-loc> ::= ram
                     | rom
                     | \e
  <storage-params> ::= <storage-param> <storage-params>
                     | \e
   <storage-param> ::= <region-name>
        <var-decl> ::= <id-list> : <type-spec> ;
                     | <id> : <type-spec> = <expr> ;

      <const-decl> ::= const <id> : <type-spec> = <constant> ;

     <region-decl> ::= <region-name> { <region-decl-body> }
     <region-name> ::= region ( <id> , <id> )
<region-decl-body> ::= <global-var-decl> <region-decl-body>
                     | \e

       <func-decl> ::= <func-heading> { <func-body> }
    <func-heading> ::= fn <id> ( <func-params> ) <func-return>
     <func-return> ::= : <type-spec>
                     | \e
     <func-params> ::= <func-params'>
                     | \e
    <func-params'> ::= <func-param> , <func-params'>
                     | <func-param>
      <func-param> ::= <id-list> : <type-spec>
       <func-body> ::= <stmt-list>


       <stmt-list> ::= <stmt> <stmt-list>
                     | \e

            <stmt> ::= <expr> ;
                     | { <stmt-list> }
                     | var <var-decl>
                     | <if-stmt>
                     | <switch-stmt>
                     | <loop-stmt>
                     | <while-stmt>
                     | <for-stmt>
                     | break ;
                     | continue ;
                     | repeat ;
                     | return ;
                     | return <expr> ;

         <if-stmt> ::= if ( <expr> ) <stmt>
                     | if ( <expr> ) <stmt> else <stmt>

     <switch-stmt> ::= switch ( <expr> ) { <switch-body> }
     <switch-body> ::= <switch-case> <switch-body>
                     | \e
     <switch-case> ::= case <const> : <stmt-list>
                     | default : <stmt-list>

       <loop-stmt> ::= loop <stmt>

      <while-stmt> ::= while ( <expr> ) <stmt>

        <for-stmt> ::= for ( <id> in <expr> ) <stmt>


            <expr> ::= <ex-comma>

         <ex-list> ::= <ex-list'>
                     | \e
        <ex-list'> ::= <ex-assign> , <ex-list'>
                     | <ex-assign>

        <ex-comma> ::= <ex-assign>
                     | <ex-assign> , <ex-comma>
       <ex-assign> ::= <ex-tern>
                     | <ex-tern> = <ex-assign>
                     | <ex-tern> += <ex-assign>
                     | <ex-tern> -= <ex-assign>
                     | <ex-tern> *= <ex-assign>
                     | <ex-tern> /= <ex-assign>
                     | <ex-tern> %= <ex-assign>
                     | <ex-tern> <<= <ex-assign>
                     | <ex-tern> >>= <ex-assign>
                     | <ex-tern> &= <ex-assign>
                     | <ex-tern> ^= <ex-assign>
                     | <ex-tern> |= <ex-assign>
         <ex-tern> ::= <ex-lor>
                     | <ex-lor> ? <ex-lor> : <ex-tern>
          <ex-lor> <<= <ex-land>
                     | <ex-land> || <ex-lor>
         <ex-land> <<= <ex-bor>
                     | <ex-bor> && <ex-land>
          <ex-bor> <<= <ex-bxor>
                     | <ex-bxor> | <ex-bor>
         <ex-bxor> <<= <ex-band>
                     | <ex-band> ^ <ex-bxor>
         <ex-band> <<= <ex-eq>
                     | <ex-eq> & <ex-band>
           <ex-eq> <<= <ex-cmp>
                     | <ex-cmp> == <ex-eq>
                     | <ex-cmp> != <ex-eq>
          <ex-cmp> <<= <ex-shift>
                     | <ex-shift> < <ex-cmp>
                     | <ex-shift> > <ex-cmp>
                     | <ex-shift> <= <ex-cmp>
                     | <ex-shift> >= <ex-cmp>
        <ex-shift> <<= <ex-add>
                     | <ex-add> << <ex-shift>
                     | <ex-add> >> <ex-shift>
          <ex-add> <<= <ex-mul>
                     | <ex-mul> + <ex-add>
                     | <ex-mul> - <ex-add>
          <ex-mul> <<= <ex-unary>
                     | <ex-unary> * <ex-mul>
                     | <ex-unary> / <ex-mul>
                     | <ex-unary> % <ex-mul>
        <ex-unary> ::= ++ <ex-unary>
                     | -- <ex-unary>
                     | ! <ex-unary>
                     | ~ <ex-unary>
                     | * <ex-unary>
                     | & <ex-unary>
                     | sizeof <ex-unary>
                     | <ex-bottom>
       <ex-bottom> <<= <ex-primary>
                     | <ex-primary> ++
                     | <ex-primary> --
                     | <ex-primary> ( <ex-list> )
                     | <ex-primary> [ <expr> ]
                     | <ex-primary> . <ex-bottom>
                     | <ex-primary> :: <ex-bottom>
      <ex-primary> ::= <id>
                     | <constant>
                     | ( <expr> )
